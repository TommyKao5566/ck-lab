<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>CKEditor Preview</title>
    <!-- Libraries for capturing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body { 
            font-family: 細明體,新細明體,Arial,sans-serif,Verdana,標楷體,微軟正黑體; 
            font-size: 12px; 
            color: #333; 
            background-color: #fff; 
            margin: 20px; 
        }
        p { margin: 0; }
        .cke_editable { 
            font-size: 20px; 
            font-family: 標楷體; 
            line-height: 1.8; 
            letter-spacing: 3pt; 
            word-spacing: 3pt; 
            margin-top: 0; 
            margin-bottom: 0; 
            border: 1px solid #ccc; /* Add a border for visual clarity */
            padding: 15px;
            width: 930px; /* Fixed width as per editor */
        }
        blockquote { 
            font-style: italic; 
            font-family: Georgia, Times, "Times New Roman", serif; 
            padding: 2px 0; 
            border-style: solid; 
            border-color: #ccc; 
            border-width: 0; 
        }
        a { color: #0782C1; }
        ol,ul,dl { margin: 0; padding: 0 40px; }
        h1,h2,h3,h4,h5,h6 { font-weight: normal; line-height: 1.2; }
        hr { border: 0px; border-top: 1px solid #ccc; }
        img.right { border: 1px solid #ccc; float: right; margin-left: 15px; padding: 5px; }
        img.left { border: 1px solid #ccc; float: left; margin-right: 15px; padding: 5px; }
        pre { white-space: pre-wrap; word-wrap: break-word; -moz-tab-size: 4; tab-size: 4; }
        .marker { background-color: Yellow; }
        #controls { padding-bottom: 10px; border-bottom: 1px solid #eee; margin-bottom: 10px; }
        .my-page {
            border-bottom: 1px dotted black;
            display: flex;
            height: 900px; /* Use myPageHeight */
        }
        .my-page::before {
            counter-increment: index;
            content: "〈第" counter(index, cjk-ideographic) "頁〉";
            margin-left: auto;
            margin-right: 25px;
            color: aquamarine;
        }
        #page-container {
            position: absolute;
            top: 35px; /* body margin 20px + cke_editable padding 15px */
            left: 35px; /* body margin 20px + cke_editable padding 15px */
            width: 930px; /* Match content width */
            pointer-events: none;
            counter-reset: index;
            z-index: 1; /* Ensure it's above the content if needed */
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="btn-capture-preview">擷取內容並下載多個圖片</button>
        <button id="btn-capture-zip">擷取內容並下載為ZIP</button>
    </div>

    <div id="page-container"></div>

    <div id="content" class="cke_editable" lang="ZH-TW" dir="ltr">
        <!-- Content will be inserted here -->
    </div>

    <script>
        // --- 1. Load content and fixed settings ---
        const myPageHeight = 900; // Fixed page height
        const pageCount = 8;      // Fixed page count
        const lineHeight = 36;    // Fixed line height
        const fontSize = 20;      // Fixed font size

        window.addEventListener('load', function() {
            // Load content
            const editorContent = localStorage.getItem('ckeditorContent');
            const contentDiv = document.getElementById('content');
            if (editorContent) {
                contentDiv.innerHTML = editorContent;
            } else {
                contentDiv.innerHTML = '<p>沒有找到預覽內容。</p>';
                // Disable buttons if no content
                document.getElementById('btn-capture-preview').disabled = true;
                document.getElementById('btn-capture-zip').disabled = true;
            }

            // Dynamically create page number overlays
            const pageContainer = document.getElementById('page-container');
            // Set the height of the page container to match the total content height for proper overlay
            pageContainer.style.height = (myPageHeight * pageCount) + 'px';
            for (let i = 0; i < pageCount; i++) {
                const pageDiv = document.createElement('div');
                pageDiv.className = 'my-page';
                pageContainer.appendChild(pageDiv);
            }
        });

        // --- 2. Capture and Download Logic (adapted from index.html) ---

        // Helper function to download a data URL
        function downloadDataUrl(dataUrl, filename) {
            const link = document.createElement('a');
            link.href = dataUrl;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Main Capture Logic
        function captureContent(callback) {
            const contentElement = document.getElementById('content');
            if (!contentElement || !contentElement.innerHTML.trim() || contentElement.innerText.includes('沒有找到預覽內容')) {
                alert('沒有內容可以擷取!');
                return;
            }

            // Use html2canvas on the element that is already displaying the content
            html2canvas(contentElement, {
                useCORS: true,
                width: contentElement.offsetWidth,
                windowWidth: contentElement.scrollWidth,
                windowHeight: contentElement.scrollHeight
            })
            .then(callback) // Pass the canvas to the callback function
            .catch(err => {
                console.error('Capture failed:', err);
                alert('圖片擷取失敗，請查看主控台以獲取詳細資訊。');
            });
        }

        // Button 1: Download individual images
        document.getElementById('btn-capture-preview').addEventListener('click', function () {
            captureContent(canvas => {
                const totalHeight = canvas.height;
                const chunkHeight = myPageHeight;
                const numChunks = Math.ceil(totalHeight / chunkHeight);
                const effectiveChunks = Math.min(numChunks, pageCount);

                function downloadChunk(chunkIndex) {
                    if (chunkIndex >= effectiveChunks) return;

                    const chunkCanvas = document.createElement('canvas');
                    const chunkCtx = chunkCanvas.getContext('2d');
                    const currentChunkHeight = Math.min(chunkHeight, totalHeight - (chunkIndex * chunkHeight));

                    chunkCanvas.width = canvas.width;
                    chunkCanvas.height = currentChunkHeight;

                    chunkCtx.drawImage(canvas, 0, chunkIndex * chunkHeight, canvas.width, currentChunkHeight, 0, 0, canvas.width, currentChunkHeight);
                    downloadDataUrl(chunkCanvas.toDataURL('image/png'), `preview-content-part-${chunkIndex + 1}.png`);

                    setTimeout(() => downloadChunk(chunkIndex + 1), 500); // Stagger downloads
                }
                downloadChunk(0);
            });
        });

        // Button 2: Download as ZIP
        document.getElementById('btn-capture-zip').addEventListener('click', function () {
            captureContent(canvas => {
                const zip = new JSZip();
                const totalHeight = canvas.height;
                const chunkHeight = myPageHeight;
                const numChunks = Math.ceil(totalHeight / chunkHeight);
                const effectiveChunks = Math.min(numChunks, pageCount);

                for (let i = 0; i < effectiveChunks; i++) {
                    const chunkCanvas = document.createElement('canvas');
                    const chunkCtx = chunkCanvas.getContext('2d');
                    const currentChunkHeight = Math.min(chunkHeight, totalHeight - (i * chunkHeight));

                    chunkCanvas.width = canvas.width;
                    chunkCanvas.height = currentChunkHeight;

                    chunkCtx.drawImage(canvas, 0, i * chunkHeight, canvas.width, currentChunkHeight, 0, 0, canvas.width, currentChunkHeight);

                    const base64Data = chunkCanvas.toDataURL('image/png').split(',')[1];
                    zip.file(`preview-content-part-${i + 1}.png`, base64Data, { base64: true });
                }

                zip.generateAsync({ type: "blob" }).then(blob => {
                    const url = URL.createObjectURL(blob);
                    downloadDataUrl(url, 'preview-content.zip');
                    URL.revokeObjectURL(url);
                });
            });
        });
    </script>
</body>
</html>
