<html>

<head>
    <meta http-equiv=Content-Type content="text/html; charset=utf-8">
    <title></title>
    <script src="./ckeditor/ckeditor.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="sampleContent.js"></script>
    <script>

        const DEFAULT_PAGE_LINES = 25;
        const PAGE_COUNTS = 8;
        const PAGE_HEIGHT = 900;
        const FONT_SIZE = 24;

        const UNDERLINE_COLOR = '0573d7';
        const BORDER_STOKE_WIDTH = 4;

        const QUESTION_NUMBER = 1;

        const urlParams = new URLSearchParams(window.location.search);
        let pageLines = +(urlParams.get('pageLines')) || DEFAULT_PAGE_LINES;

        // line-height必定大於等於1，否則上下字體會重疊，難以閱讀
        // line-height >= 1
        // (line-height * pageLines * FONT_SIZE = PAGE_HEIGHT) >= pageLines * FONT_SIZE
        // PAGE_HEIGHT >= pageLines * FONT_SIZE
        // PAGE_HEIGHT / FONT_SIZE >= pageLines

        // 不滿足上面推導的情形，行數過多，會導致上下字體重疊，則設為預設行數
        if (pageLines > PAGE_HEIGHT / FONT_SIZE) {
            pageLines = DEFAULT_PAGE_LINES;
        }

        lineHeight = PAGE_HEIGHT / pageLines;

        document.write(`
            <style>
                .my-page { 
                    height: ${PAGE_HEIGHT - BORDER_STOKE_WIDTH}px;
                    border: ${BORDER_STOKE_WIDTH}px solid #${UNDERLINE_COLOR};
                    display: flex;
                }
                .my-page::before {
                    color: #${UNDERLINE_COLOR};
                }
                .my-page:not(:last-child) {
                    border-bottom: none;
                }
                .my-page::before {
                    counter-increment: index;
                    content: "第\\A  ${QUESTION_NUMBER} \\A題\\A第\\A  " counter(index) "\\A頁";
                    white-space: pre-line;
                    margin-left: -25px;
                    text-align: center;
                }
                .watermark::before {
                    counter-increment: index;
                    content: "第\\A  ${QUESTION_NUMBER} \\A題\\A第\\A  " counter(index) "\\A頁";
                    color: grey;
                    font-size: 60px;
                    white-space: pre-line;
                    opacity: 0.5;
                }
                .right-text {
                    position: absolute;
                    width: 100%;
                    writing-mode: vertical-rl;
                    text-orientation: upright;
                    color: #${UNDERLINE_COLOR};
                    letter-spacing: 5px;
                }
                .right-text > div {
                    margin-right: -25px;
                }
            </style>
        `);

        const customCss = `.cke_editable { 
                font-size: ${FONT_SIZE}px;
                line-height: ${lineHeight / FONT_SIZE};
                overflow: hidden;
                margin-top:0;
                margin-bottom:0;
            }
            .note-lines {
                line-height: ${lineHeight}px;
                background-image: url("data:image/svg+xml;utf8,\
            <svg xmlns='http://www.w3.org/2000/svg' width='100%' height='${lineHeight}'>\
            <line x1='0' y1='${lineHeight - 1}' x2='100%' y2='${lineHeight - 1}' stroke='%23${UNDERLINE_COLOR}' stroke-width='1'/>\
            </svg>");
                background-repeat: repeat-y;
                background-size: 100% ${lineHeight}px;
            }`

    </script>
    <style>
        #cke_1_top {
            position: fixed;
            width: 728px;
            top: 42px;
            z-index: 1;
        }

        #cke_1_contents {
            padding-top: 70px;
        }


        #page-container {
            padding-top: 70px;
            position: absolute;
            top: 0;
            width: -webkit-fill-available;
            pointer-events: none;
            /* 初始化計數器 */
            counter-reset: index;
        }

        #hint {
            position: fixed;
            top: 0;
            z-index: 1;
            background: white;
            width: 935px;
            height: 42px;
        }

        #preview_container {
            position: fixed;
            z-index: 2;
            top: 40px;
            height: calc(100vh - 40px);
            width: 95vw;
            display: none;
            background-color: white;
            /* 兩欄 */
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            overflow-y: auto;
            /* 初始化計數器 */
            counter-reset: index;
        }

        .preview_inner {
            /* 人工調整 */
            aspect-ratio: 0.825;
            background-size: cover;
            background-repeat: no-repeat;
            background-position-y: 900;
            border: black 4pt solid;
            display: flex;
        }

        .watermark {
            width: -webkit-fill-available;
            text-align: center;
        }
    </style>
</head>

<!-- text-justify-trim: punctuation 是 CSS Text Level 4 的一個屬性，用來控制「文本對齊時要不要修剪（trim）標點符號」。

但 重要重點：目前幾乎沒有瀏覽器支援（Chrome / Firefox / Safari 通通不支援）。 -->

<body lang=ZH-TW style='text-justify-trim:punctuation'>
    <div id="preview_container">
    </div>
    <center>
        <table border=0>
            <tr id="hint">
                <td align=left><b>作答區：(可切換輸入法進行輸入)</b>
                    <button id="preview_button">預覽模式</button>
                    <button id="edit_button" onclick="editMode()">編輯模式</button>
                </td>
            </tr>
            <tr>
                <td style="position: relative;">
                    <textarea id='content001' name='content001'></textarea>
                    <div id="page-container">
                        <div class="right-text">
                            <div>
                                （請從第1頁第1行依序開始書寫）
                            </div>
                        </div>
                        <div class="my-page"></div>
                        <div class="my-page"></div>
                        <div class="my-page"></div>
                        <div class="my-page"></div>
                        <div class="my-page"></div>
                        <div class="my-page"></div>
                        <div class="my-page"></div>
                        <div class="my-page"></div>
                    </div>
                </td>
            </tr>
        </table>
    </center>

</body>
<script type='text/javascript'>
    if (window.navigator.userAgent.indexOf('Chrome') > -1) {
        let editor1;
        const editorHeight = PAGE_HEIGHT * PAGE_COUNTS; // Define editor height here

        if (null != document.getElementById('content001')) {
            //editor1 = CKEDITOR.replace('content001',{contentsCss : 'body {overflow:hidden;}'});
            editor1 = CKEDITOR.replace('content001', {
                height: editorHeight,
                contentsCss: ['./ckeditor/contents.css',
                    'data:text/css,' + encodeURIComponent(customCss)
                ]
            });
            editor1.updateElement();

            editor1.on('instanceReady', function () {
                this.document.getBody().addClass('note-lines');
            })

            editor1.on('key', function (evt) {
                if (evt.data.keyCode === 13) { // Enter key
                    if (this._isEnterKeyDown) { // Check if Enter is already held down
                        throw new Error("阻止連續的enter");
                    } else {
                        this._isEnterKeyDown = true; // Mark Enter as held down
                    }
                }
            });

            editor1.on('keyup', function (evt) {
                this._isEnterKeyDown = false; // Reset the flag
            });

            let initialData = '';
            for (let i = 1; i <= pageLines; i++) {
                initialData += `${i}<br>`;
            }
            initialData = initialData.repeat(PAGE_COUNTS);
            editor1.setData(sampleContent1);
        }
    }

</script>
<script>

    // init preview div
    document.getElementById('preview_container')
        .insertAdjacentHTML('beforeend', Array.from({ length: PAGE_COUNTS }, (_, i) => `<div class="preview_inner" style="background-position-y: ${(100 * i) / (PAGE_COUNTS - 1)}%;" onclick="scrollToPage(${i})"><div class="watermark"></div></div>`).join(''));


    const preview_button = document.getElementById('preview_button')

    preview_button.addEventListener('click', () => {

        document.getElementById('preview_container').style.display = 'grid';

        CKEDITOR.instances.content001.setReadOnly(true);

        captureEditorContent()

        console.log(document.getElementsByTagName('body'))

        document.getElementsByTagName('body')[0].style.overflowY = 'hidden';


    });

</script>
<script>

    function editMode() {
        document.getElementById('preview_container').style.display = 'none';
        document.getElementsByTagName('body')[0].style.overflowY = 'auto';

        CKEDITOR.instances.content001.setReadOnly(false);
    }

    function scrollToPage(index) {

        // go below to enable
        //chrome://flags/#smooth-scrolling

        window.scrollTo(
            {
                top: index * PAGE_HEIGHT,            // 滾動到頂部
                left: 0,           // 水平位置
                behavior: 'smooth' // 平滑滾動
            }
        );

        editMode();

    }
</script>
<script>

    // 定義一個判斷按鍵是否為上下左右箭頭或 Backspace 的函數
    function isAllowedKey(e) {
        const allowedKeys = [
            "Escape",      // Esc
            "Home",        // Home
            "End",         // End
            "PageUp",      // PageUp
            "PageDown",    // PageDown
            "Insert",      // Insert
            "CapsLock",    // CapsLock
            "NumLock",     // NumLock
            "ScrollLock",  // ScrollLock
            "Control",     // Control
            "Alt",         // Alt
            "AltGraph",    // AltGraph（右邊的 Alt）
            "Meta",        // Meta（Windows / Command 鍵）

            "ArrowUp",     // 上箭頭
            "ArrowDown",   // 下箭頭
            "ArrowLeft",   // 左箭頭
            "ArrowRight",  // 右箭頭
            "Backspace",   // Backspace 鍵
            "Delete"       // Delete 鍵
        ];

        Array.from({ length: 12 }, (_, i) => 'F' + (i + 1)).forEach(fnKey => allowedKeys.push(fnKey))

        return allowedKeys.includes(e.key);
    }

    let showLastWarning = true;

    (function () {
        const maxHeight = PAGE_COUNTS * PAGE_HEIGHT;
        let iframeDoc = null;

        // Function to check the height and show an alert
        function checkHeight(event) {

            const contentHeight = iframeDoc.body.scrollHeight;

            if (contentHeight > (maxHeight - PAGE_HEIGHT)) {

                if (showLastWarning === true) {
                    showLastWarning = false;
                    alert(`已達最末頁，請注意作答長度。`);
                }
            } else {
                showLastWarning = true;
            }

            // Do not trigger on Backspace or Delete
            if (event && isAllowedKey(event)) return;

            // A small timeout to let the DOM update after the event
            setTimeout(function () {

                if (!iframeDoc) return;

                if (contentHeight > maxHeight) {
                    alert(`作答超過本頁長度，請刪減字數。`);
                    CKEDITOR.instances.content001.execCommand('undo');
                    // 避免使用者透過按鈕取消回上一步
                    CKEDITOR.instances.content001.resetUndo();
                }
            }, 100); // A small delay for rendering
        }

        // Wait for the editor's iframe to be created
        const initInterval = setInterval(function () {
            const editorIframe = document.querySelector('#cke_1_contents iframe');
            if (editorIframe && editorIframe.contentWindow && editorIframe.contentWindow.document) {
                iframeDoc = editorIframe.contentWindow.document;
                clearInterval(initInterval); // Stop polling

                // Attach event listeners as requested
                iframeDoc.addEventListener('keyup', checkHeight);
                iframeDoc.addEventListener('paste', checkHeight); // Also check on paste


                iframeDoc.addEventListener("keydown", function (e) {
                    const contentHeight = iframeDoc.body.scrollHeight;

                    if (isAllowedKey(e)) return;

                    if ((contentHeight > maxHeight)) {
                        e.preventDefault();
                    }
                });

            }
        }, 100);
    })();
</script>
<script>

    // --- Helper function to download a data URL ---
    function downloadDataUrl(dataUrl, filename) {
        const link = document.createElement('a');
        link.href = dataUrl;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.appendChild(link);
        document.body.removeChild(link);
    }

    // --- Main Capture Logic (used by both buttons) ---
    function captureEditorContent() {

        const editor = CKEDITOR.instances.content001;
        if (!editor) {
            alert('Editor not found!');
            return;
        }

        const previewData = editor.getData();
        const editorWidth = editor.config.width; // Get actual editor width

        // 編輯器內cke_editable，height不可指定，因為需要計算長度彈出警告
        // 預覽視窗內cke_editable，height必須指定，否則無法計算高度分割圖片。
        const previewHtml = `<!DOCTYPE html>
      <html class="note-lines">
        <head>
         <link rel="stylesheet" href="./ckeditor/contents.css">
          <style>
            ${customCss}
          </style>   
          <style>
            .cke_editable { 
                height:${PAGE_COUNTS * PAGE_HEIGHT}px;
            }
          </style>
        </head>
        <body class="cke_editable cke_editable_themed cke_contents_ltr cke_show_borders note-lines">
          ${previewData}
        </body>
      </html>`;

        // 1. Create a temporary, off-screen iframe.
        const iframe = document.createElement('iframe');
        iframe.style.position = 'absolute';
        iframe.style.left = '-9999px';
        iframe.style.width = editorWidth + 'px';
        // The height will be determined by the content
        iframe.style.height = '1px'; // Start small, will grow
        iframe.style.border = '0';

        document.body.appendChild(iframe);

        // 2. Write the HTML content into the iframe.
        iframe.contentWindow.document.open();
        iframe.contentWindow.document.write(previewHtml);
        iframe.contentWindow.document.close();

        // 3. Wait for the iframe content to load fully (including external CSS).
        iframe.onload = function () {
            // Adjust iframe height to content
            const contentHeight = iframe.contentWindow.document.body.scrollHeight;
            iframe.style.height = contentHeight + 'px';

            // Add a small delay to ensure rendering is complete
            setTimeout(() => {
                // 4. Run html2canvas on the iframe's body.
                html2canvas(iframe.contentWindow.document.documentElement, {
                    useCORS: true,
                    width: editorWidth,
                    height: contentHeight,
                    windowWidth: editorWidth,
                    windowHeight: contentHeight,
                    scale: window.devicePixelRatio
                })
                    .then(canvas => {
                        const dataUrl = canvas.toDataURL('image/png');
                        console.log('Generated Data URL:', dataUrl);
                        if (dataUrl === 'data:,') {
                            console.error('Canvas is blank. The generated data URL is empty.');
                            alert('擷取到的圖片是空白的，請檢查主控台。');
                            return;
                        }

                        // const previewInner = document.querySelector('.preview_inner');
                        // if (previewInner) {
                        //     previewInner.style.backgroundImage = `url('${dataUrl}')`;

                        // } else {
                        //     console.error('Error: .preview_inner element not found.');
                        // }

                        for (const sheet of document.styleSheets) {
                            try {
                                const rules = sheet.cssRules;
                                for (const rule of rules) {
                                    if (rule.selectorText === '.preview_inner') {
                                        // 直接改寫 CSS
                                        rule.style.backgroundImage = `url('${dataUrl}')`
                                    }
                                }
                            } catch (e) {
                                // 跨域的 stylesheet 不能操作
                            }
                        }

                    })
                    .catch(err => {
                        console.error('Capture failed:', err);
                        // alert('圖片擷取失敗，請查看主控台以獲取詳細資訊。');
                    })
                    .finally(() => {
                        // 5. Clean up by removing the iframe, but with a delay to avoid potential race conditions.
                        setTimeout(() => {
                            if (iframe && iframe.parentElement) {
                                iframe.parentElement.removeChild(iframe);
                            }
                        }, 2000); // Wait 2 seconds before removing
                    });
            }, 200); // 200ms delay for rendering safety
        };

        // Handle case where onload doesn't fire for about:blank
        if (iframe.contentWindow.document.readyState === 'complete') {
            iframe.onload();
        }
    }
</script>

</html>