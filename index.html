<html>

<head>
    <meta http-equiv=Content-Type content="text/html; charset=utf-8">
    <title></title>
    <script src="./ckeditor/ckeditor.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>

        const DEFAULT_PAGE_LINES = 25;
        const PAGE_COUNTS = 8;
        const PAGE_HEIGHT = 900
        const FONT_SIZE = 20

        const urlParams = new URLSearchParams(window.location.search);
        let pageLines = +(urlParams.get('pageLines')) || DEFAULT_PAGE_LINES;

        // line-height必定大於等於1，否則上下字體會重疊，難以閱讀
        // line-height >= 1
        // (line-height * pageLines * FONT_SIZE = PAGE_HEIGHT) >= pageLines * FONT_SIZE
        // PAGE_HEIGHT >= pageLines * FONT_SIZE
        // PAGE_HEIGHT / FONT_SIZE >= pageLines

        // 不滿足上面推導的情形，行數過多，會導致上下字體重疊，則設為預設行數
        if (pageLines > PAGE_HEIGHT / FONT_SIZE) {
            pageLines = DEFAULT_PAGE_LINES;
        }

        lineHeight = PAGE_HEIGHT / pageLines;

        //                                border bottom height = 1
        document.write(`<style>.my-page { height: ${PAGE_HEIGHT - 1}px; }</style>`);
    </script>
    <style>
        #cke_1_top {
            position: fixed;
            width: 914px;
            top: 42px;
        }

        #cke_1_contents {
            padding-top: 70px;
        }

        .my-page {
            border-bottom: 1px dotted black;
            display: flex;
        }

        .my-page::before {
            counter-increment: index;
            content: "〈第" counter(index, cjk-ideographic) "頁〉";
            margin-left: auto;
            /* 自動推到右邊 */
            margin-right: 25px;
            color: aquamarine;
        }

        #page-container {
            padding-top: 70px;
            position: absolute;
            top: 0;
            width: -webkit-fill-available;
            pointer-events: none;
            counter-reset: index;
            /* 初始化計數器 */
        }

        #hint {
            position: fixed;
            top: 0;
            z-index: 1;
            background: white;
            width: 935px;
            height: 42px;
        }

        .preview_container {
            position: fixed;
            z-index: 2;
            height: 90vh;
            width: 465px;
            display: none;
        }

        .preview_inner {
            scale: 0.5;
            position: absolute;
            overflow-y: scroll;
            overflow-x: hidden;
            top: -50%;
            height: 200%;
            left: -50%;
            width: 200%;
        }
    </style>
</head>

<body lang=ZH-TW style='text-justify-trim:punctuation'>
    <div class="preview_container">
        <div class="preview_inner" onclick="scrollToPage(0)">
            <!-- img... -->
        </div>
        <!-- repeat 8 times -->
    </div>
    <center>

        <table border=0>
            <tr id="hint">
                <td align=left><b>作答區：(可切換輸入法進行輸入)</b>
                    <button id="preview_button">預覽模式</button>
                    <button id="edit_button" onclick="editMode()">編輯模式</button>
                </td>
            </tr>
            <tr>
                <td style="position: relative;">
                    <textarea id='content001' name='content001'></textarea>
                    <div id="page-container">
                        <div class="my-page"></div>
                        <div class="my-page"></div>
                        <div class="my-page"></div>
                        <div class="my-page"></div>
                        <div class="my-page"></div>
                        <div class="my-page"></div>
                        <div class="my-page"></div>
                        <div class="my-page"></div>
                    </div>
                </td>
            </tr>
        </table>
    </center>

</body>
<script type='text/javascript'>
    if (window.navigator.userAgent.indexOf('Chrome') > -1) {
        let editor1;
        const editorHeight = PAGE_HEIGHT * PAGE_COUNTS; // Define editor height here

        if (null != document.getElementById('content001')) {
            //editor1 = CKEDITOR.replace('content001',{contentsCss : 'body {overflow:hidden;}'});
            editor1 = CKEDITOR.replace('content001', {
                height: editorHeight,
                contentsCss: ['./ckeditor/contents.css',
                    'data:text/css,' + encodeURIComponent(`
                        .cke_editable { font-size: ${FONT_SIZE}px; line-height: ${lineHeight / FONT_SIZE}; overflow-y: hidden; margin-top:0; margin-bottom:0;}
                    `)
                ]
            });
            CKEDITOR.instances['content001'].updateElement();

            editor1.on('key', function (evt) {
                if (evt.data.keyCode === 13) { // Enter key
                    if (this._isEnterKeyDown) { // Check if Enter is already held down
                        throw new Error("阻止連續的enter");
                    } else {
                        this._isEnterKeyDown = true; // Mark Enter as held down
                    }
                }
            });

            editor1.on('keyup', function (evt) {
                this._isEnterKeyDown = false; // Reset the flag
            });

            let initialData = '';
            for (let i = 1; i <= pageLines; i++) {
                initialData += `${i}<br>`;
            }
            initialData = initialData.repeat(PAGE_COUNTS);
            editor1.setData(initialData);
        }
    }

</script>
<script>

    const preview_button = document.getElementById('preview_button')

    preview_button.addEventListener('click', () => {

        document.getElementsByClassName('preview_container')[0].style.display = 'unset';

        CKEDITOR.instances.content001.setReadOnly(true);

        captureEditorContent()

    });



</script>
<script>

    function editMode() {
        document.getElementsByClassName('preview_container')[0].style.display = 'none';

        CKEDITOR.instances.content001.setReadOnly(false);
    }

    function scrollToPage(index) {

        // go below to enable
        //chrome://flags/#smooth-scrolling

        window.scrollTo(
            {
                top: index * PAGE_HEIGHT,            // 滾動到頂部
                left: 0,           // 水平位置
                behavior: 'smooth' // 平滑滾動
            }
        );

        editMode();

    }
</script>
<script>

    // 定義一個判斷按鍵是否為上下左右箭頭或 Backspace 的函數
    function isAllowedKey(e) {
        const allowedKeys = [
            "Escape",      // Esc
            "Home",        // Home
            "End",         // End
            "PageUp",      // PageUp
            "PageDown",    // PageDown
            "Insert",      // Insert
            "CapsLock",    // CapsLock
            "NumLock",     // NumLock
            "ScrollLock",  // ScrollLock
            "Control",     // Control
            "Alt",         // Alt
            "AltGraph",    // AltGraph（右邊的 Alt）
            "Meta",        // Meta（Windows / Command 鍵）

            "ArrowUp",     // 上箭頭
            "ArrowDown",   // 下箭頭
            "ArrowLeft",   // 左箭頭
            "ArrowRight",  // 右箭頭
            "Backspace",   // Backspace 鍵
            "Delete"       // Delete 鍵
        ];

        Array.from({ length: 12 }, (_, i) => 'F' + (i + 1)).forEach(fnKey => allowedKeys.push(fnKey))

        return allowedKeys.includes(e.key);
    }

    (function () {
        const maxHeight = PAGE_COUNTS * PAGE_HEIGHT;
        let iframeDoc = null;

        // Function to check the height and show an alert
        function checkHeight(event) {
            // Do not trigger on Backspace or Delete
            if (event && isAllowedKey(event)) return;

            // A small timeout to let the DOM update after the event
            setTimeout(function () {
                if (!iframeDoc) return;
                const contentHeight = iframeDoc.body.scrollHeight;

                if (contentHeight > maxHeight) {
                    alert(`內容高度已超過 ${maxHeight}px，您剛才輸入的內容已被移除。`);
                    // CKEDITOR.instances.content001.execCommand('undo');
                    // 避免使用者透過按鈕取消回上一步
                    // CKEDITOR.instances.content001.resetUndo();
                }
            }, 100); // A small delay for rendering
        }

        // Wait for the editor's iframe to be created
        const initInterval = setInterval(function () {
            const editorIframe = document.querySelector('#cke_1_contents iframe');
            if (editorIframe && editorIframe.contentWindow && editorIframe.contentWindow.document) {
                iframeDoc = editorIframe.contentWindow.document;
                clearInterval(initInterval); // Stop polling

                // Attach event listeners as requested
                iframeDoc.addEventListener('keyup', checkHeight);
                iframeDoc.addEventListener('paste', checkHeight); // Also check on paste


                iframeDoc.addEventListener("keydown", function (e) {
                    const contentHeight = iframeDoc.body.scrollHeight;

                    if (isAllowedKey(e)) return;

                    // if ((contentHeight > maxHeight)) {
                    //     e.preventDefault();
                    // }
                });

            }
        }, 100);
    })();
</script>
<script>

    // --- Helper function to download a data URL ---
    function downloadDataUrl(dataUrl, filename) {
        const link = document.createElement('a');
        link.href = dataUrl;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.appendChild(link);
        document.body.removeChild(link);
    }

    // --- Main Capture Logic (used by both buttons) ---
    function captureEditorContent() {

        const editor = CKEDITOR.instances.content001;
        if (!editor) {
            alert('Editor not found!');
            return;
        }

        const previewData = editor.getData();
        const editorWidth = editor.container.getClientRect().width || 800; // Get actual editor width

        const previewHtml = `<!DOCTYPE html>
      <html>
        <head>
         <link rel="stylesheet" href="./ckeditor/contents.css">
          <style>
            body { 
                width: ${editorWidth}px; 
                border: none; 
                margin: 0; 
                padding: 0;
            }
            .cke_editable { 
                font-size: ${FONT_SIZE}px; 
                line-height: ${lineHeight / FONT_SIZE}; 
                overflow: hidden; 
                margin-top:0; 
                margin-bottom:0; 
                user-select: none;
            }
          </style>
        </head>
        <body class="cke_editable cke_editable_themed cke_contents_ltr cke_show_borders">
          ${previewData}
        </body>
      </html>`;

        // 1. Create a temporary, off-screen iframe.
        const iframe = document.createElement('iframe');
        iframe.style.position = 'absolute';
        iframe.style.left = '-9999px';
        iframe.style.width = editorWidth + 'px';
        // The height will be determined by the content
        iframe.style.height = '1px'; // Start small, will grow
        iframe.style.border = '0';

        document.body.appendChild(iframe);

        // 2. Write the HTML content into the iframe.
        iframe.contentWindow.document.open();
        iframe.contentWindow.document.write(previewHtml);
        iframe.contentWindow.document.close();

        // 3. Wait for the iframe content to load fully (including external CSS).
        iframe.onload = function () {
            // Adjust iframe height to content
            const contentHeight = iframe.contentWindow.document.body.scrollHeight;
            iframe.style.height = contentHeight + 'px';

            // Add a small delay to ensure rendering is complete
            setTimeout(() => {
                // 4. Run html2canvas on the iframe's body.
                html2canvas(iframe.contentWindow.document.body, {
                    useCORS: true,
                    width: editorWidth,
                    height: contentHeight,
                    windowWidth: editorWidth,
                    windowHeight: contentHeight
                })
                    .then(canvas => {
                        const dataUrl = canvas.toDataURL('image/png');
                        console.log('Generated Data URL:', dataUrl);
                        if (dataUrl === 'data:,') {
                            console.error('Canvas is blank. The generated data URL is empty.');
                            alert('擷取到的圖片是空白的，請檢查主控台。');
                            return;
                        }

                        const newWindow = window.open('', 'editor-content');
                        if (!newWindow || newWindow.closed || typeof newWindow.closed == 'undefined') {
                            alert('無法開啟新視窗，可能被彈出視窗攔截器阻擋了。');
                        } else {
                            // Create an img element in the new window
                            newWindow.document.write('<html><head><title>editor-content.png</title></head><body style="margin:0;"><img src="' + dataUrl + '" style="max-width: 100%;"></body></html>');
                            newWindow.document.close();
                        }
                    })
                    .catch(err => {
                        console.error('Capture failed:', err);
                        alert('圖片擷取失敗，請查看主控台以獲取詳細資訊。');
                    })
                    .finally(() => {
                        // 5. Clean up by removing the iframe.
                        // document.body.removeChild(iframe);
                    });
            }, 200); // 200ms delay for rendering safety
        };

        // Handle case where onload doesn't fire for about:blank
        if (iframe.contentWindow.document.readyState === 'complete') {
            iframe.onload();
        }
    }
</script>

</html>